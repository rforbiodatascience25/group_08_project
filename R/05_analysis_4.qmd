---
title: "Group08 - 05_analysis_3"
subtitle: "PCA plot"
author: "Greta"
format: html
editor: visual
---

## Load packages

```{r}
library("tidyverse")
library("broom")
library("janitor")
```

## Load data

```{r}
clean_data <- read_tsv("../_raw/data/03_dat_aug.tsv")
clean_data

```

## **Create a PCA object**

First, we run PCA and store the result in a variable called `pca_data`. To use the `prcomp()` function, we need to remove all non-numeric columns from the data. We can do this with the `where(is.numeric)`.

Second, we standardize the numeric variables (gene expression values) before performing PCA to make their scales comparable. We do this by setting the argument `scale = TRUE` inside `prcomp()`.

```{r}
# 1. Make sure expression is numeric
clean_data <- clean_data |>
  mutate(expression = as.numeric(expression))

# 2. Drop rows with missing genes or samples (optional but safe)
clean_data <- clean_data |>
  filter(!is.na(gene), !is.na(GSM))

# 3. Pivot wider: genes become columns, expression fills the values
clean_wide <- clean_data |>
  pivot_wider(
    names_from = gene, 
    values_from = expression,
    values_fill = list(expression = 0)   # replace missing expression with 0
  )
```

```{r}
# 1. Make sure expression is numeric
clean_data <- clean_data |>
  mutate(expression = as.numeric(expression))

# 2. Drop rows with missing genes or samples (optional but safe)
clean_data <- clean_data |>
  filter(!is.na(gene), !is.na(sample))

# 3. Pivot wider: genes become columns, expression fills the values
clean_wide <- clean_data |>
  pivot_wider(
    names_from = gene, 
    values_from = expression,
    values_fill = list(expression = 0)   # replace missing expression with 0
  )


clean_wide <- clean_data |>
  pivot_wider(
    names_from = gene,
    values_from = expression,
    values_fill = list(expression = 0)   # must be a named list
  )

#Perform PCA using only the 'average' column
clean_wide |>
  dplyr::select(expression, average) |>   # Select only the column named 'average'
  prcomp(scale = TRUE)        # Run PCA with scaling (mean = 0, sd = 1; i.e. every variable contributes equally to the PCA) 
```

**Plotting the data in PC coordinates.** To do this, we combine the PCA results (the PC coordinates) with the original dataset. This allows us to group the samples by categorical variables that were removed before performing PCA. We can do this using the `augment()` function from **broom**. The new columns containing the PCA coordinates are named `.fittedPC1`, `.fittedPC2`, and so on.

```{r}
pca_fit |>
  augment(clean_data) |> 
  mutate(
    condition_tissue = paste(condition, tissue, sep = "-"),
    time_num = as.numeric(sub("h", "", timepoint)),
    # converts "0h" → "0", get numeric values for better visualization
    timepoint = factor(
      time_num,
      levels = sort(unique(time_num)) # convert to ordered factor
    )
  ) |>
  ggplot(aes(.fittedPC1, .fittedPC2, color = timepoint, shape = condition_tissue)) +
  geom_point(size = 2) +
  labs(title = "PC coordinates plot", 
       subtitle = "PCA of gene expression across \nTissue, Condition, and Timepoint", 
         x = "Fitted PC1", y = "Fitted PC2", 
         color = "Timepoint") +
  theme_minimal()

```

**Very strong separation by tissue** along PC1 and **strong separation by condition + timepoint** along PC2.

The largest source of gene expression variation is tissue type.

**PC2 reflects the cold response trajectory over time.** Early cold response is closer to control. Later timepoints diverge strongly in gene expression.

## **Create a rotation matrix**

Next, we’ll plot the **rotation matrix**, which shows how the original variables relate to the PCs.

The rotation matrix is stored in `pca_fit$rotation`.

To make it easier to work with, we can use the **`tidy()` function** from the `broom` package. For `prcomp` objects, `tidy()` needs an extra argument: `matrix = "rotation"`. This tells `tidy()` to extract the **rotation matrix** specifically.

```{r}
# extract rotation matrix
pca_wide <- pca_fit |>
  tidy(matrix = "rotation") |>
  pivot_wider(names_from = PC, values_from = value)

```

```{r}
# Turning data into wide data
pca_wide <- pca_fit |>
  pivot_wider(names_from = PC, values_from = value)

#To reduce the noice, top 30% most variable genes are choosen in order to balance signal vs noise.


# define arrow style for plotting
arrow_style <- arrow(
  angle = 20, ends = "first", type = "closed", length = grid::unit(8, "pt")
)
```

```{r}
# plot rotation matrix
pca_fit |>
  tidy(matrix = "rotation") |>
  pivot_wider(names_from = "PC", names_prefix = "PC", values_from = "value") |>
  ggplot(aes(PC1, PC2)) +
  geom_segment(xend = 0, yend = 0, arrow = arrow_style) +
  geom_text(
    aes(label = column),
    hjust = 1, nudge_x = -0.02, 
    color = "#904C2F"
  ) +
  xlim(-1.25, .5) + ylim(-.5, 1) +
  coord_fixed() + # fix aspect ratio to 1:1
  theme_minimal()

```

## Look at the variance explained by each PC

Finally, we’ll plot the variance explained by each PC. We can again extract this information using the `tidy()` function from broom, now by setting the `matrix` argument to `matrix = "eigenvalues"`.

```{r}
pca_data |>
  tidy(matrix = "eigenvalues")
```

```{r}
pca_data |>
  tidy(matrix = "eigenvalues") |>
  ggplot(aes(PC, percent)) +
  geom_col(fill = "#56B4E9", alpha = 0.8) +
  scale_x_continuous(breaks = 1:9) +
  scale_y_continuous(
    labels = scales::percent_format(),
    expand = expansion(mult = c(0, 0.01))
  ) +
  theme_minimal()
```
