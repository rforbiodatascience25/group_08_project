---
title: "01_load"
author: "Eleni"
format:
  html:
    output-dir: results
editor: visual
---

## 0. Load required packages

```{r}

# Install required packages only if missing
if (!require("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

required <- c("tidyverse", "stringr", "janitor", 
              "AnnotationDbi", "ath1121501.db")

for (pkg in required) {
  if (!requireNamespace(pkg, quietly = TRUE)) {
    BiocManager::install(pkg, update = FALSE, ask = FALSE)
  }
}

library(tidyverse)
library(stringr) # for string operations (pattern matching, cleaning text, etc.)
library(janitor) # for cleaning column names and simple data cleaning functions, helps tidy data frames
library(AnnotationDbi) # provides functions to map probe IDs to gene IDs toretrieve annotations and work with Bioconductor genomic databases.
library(ath1121501.db) # Affymetrix Arabidopsis ATH1 annotation database
```

## 1. **Read Original Series Matrix Files (With Metadata)**

```{r}
#These GEO Series Matrix files contain:
#   - an expression matrix (gene probes × samples)
#   - multiple metadata lines (starting with '!', '#', or '^')
# Because of this, we read them line-by-line instead of loading as a table.

file_5620 <- "../_raw/data/GSE5620_series_matrix.txt.gz" # CONTROL
file_5621 <- "../_raw/data/GSE5621_series_matrix.txt.gz" # STRESS

#Read the files as plain text (line by line) so metadata can be parsed
raw_5620 <- readLines(file_5620)
raw_5621 <- readLines(file_5621)
```

## **2. Extract Sample Metadata (Titles + GSM IDs)**

```{r}
# This function extracts sample info (titles + GSM IDs) from the GEO file.
# It now also looks inside each sample title and automatically assigns
# a condition based on whether the title contains "Control" or "Cold".
extract_metadata <- function(raw_lines) {
  
  # Find the line with all sample titles
  title_line <- raw_lines[str_detect(raw_lines, "^!Sample_title")]
  
  # Find the line with all GSM IDs
  gsm_line <- raw_lines[str_detect(raw_lines, "^!Sample_geo_accession")]
  
  # Remove the part before the first tab so we keep only values
  title_clean <- str_remove(title_line, "^!Sample_title\t")
  gsm_clean   <- str_remove(gsm_line, "^!Sample_geo_accession\t")
  
  # Split into individual entries
  titles <- str_split(title_clean, "\t")[[1]]
  gsm    <- str_split(gsm_clean,   "\t")[[1]]
  
  # Remove quotes
  titles <- str_remove_all(titles, '"')
  gsm    <- str_remove_all(gsm, '"')
  
  # Determine condition from the title text
  # We convert titles to lowercase to make matching easier.
  condition <- case_when(
    str_detect(tolower(titles), "control") ~ "control",
    str_detect(tolower(titles), "cold")    ~ "cold",
    TRUE ~ "unknown"   # fallback if neither appears
  )
  
  # Return the metadata table
  tibble(GSM = gsm, title = titles, condition = condition)
}

# Extract metadata from each dataset
meta_5620 <- extract_metadata(raw_5620)
meta_5621 <- extract_metadata(raw_5621)

```

## 3. **Parse Metadata Into Structured Variables**

```{r}
# This function extracts useful pieces of information from the sample title.
# Each title contains the tissue type, the timepoint, and the replicate number.
# We pull these out using pattern matching.
parse_title <- function(df) {
  df |>
    mutate(
      # Extract whether the sample is from Shoots or Roots
      tissue = str_extract(title, "(Shoots|Roots)"),

      # Extract the timepoint (e.g., "0h", "6.0h")
      timepoint = str_extract(title, "[0-9.]+h"),

      # Extract the replicate number (e.g., "Rep1")
      replicate = str_extract(title, "Rep[0-9]")
      
      # No need for a treatment column here,
      # because we already have a clean 'condition' column.
    )
}

# Apply the parsing function to the metadata for each dataset
meta_5620 <- parse_title(meta_5620)
meta_5621 <- parse_title(meta_5621)

# Combine the two metadata tables into one complete table
sample_metadata <- bind_rows(meta_5620, meta_5621)

```

## 4. Save clean metadata table

```{r}
# Ensure _raw/data directory exists
if (!dir.exists("../_raw/data")) dir.create("../_raw/data", recursive = TRUE)

# Save clean metadata as TSV (recommended for bioinformatics)
readr::write_tsv(sample_metadata, "../_raw/data/sample_metadata.tsv")


```

## 5. **Load Expression Matrices (numeric table only)**

```{r}
# These two lines read the numeric expression matrices from the original GEO Series Matrix files. By using comment.char = "!", we tell R to skip all lines starting with "!", which are metadata lines (we have already extracted what we need).
# Only the actual expression table (probe IDs + expression values) is loaded.
# row.names = 1 sets the first column (the probe IDs) as row names.

gse5620 <- read.delim(file_5620, comment.char = "!", row.names = 1)
gse5621 <- read.delim(file_5621, comment.char = "!", row.names = 1)

# Combine the two datasets side by side.
# The rows are probe IDs, so cbind() matches them automatically.
# This gives us one full expression matrix with all samples.
expr_all <- cbind(gse5620, gse5621)

```

## **6. Annotate Probe IDs → Gene Symbols**

```{r}
# 1. Get annotation
probe_to_gene <- AnnotationDbi::select(
  ath1121501.db,
  keys = rownames(expr_all),
  columns = c("PROBEID", "GENENAME", "SYMBOL"),
  keytype = "PROBEID"
)

# 2. Clean column names → probeid, genename, symbol
probe_to_gene <- janitor::clean_names(probe_to_gene)

# 3. Remove duplicated probe IDs (rare but safe)
probe_to_gene <- dplyr::distinct(probe_to_gene, probeid, .keep_all = TRUE)

# 4. Prepare expression matrix with probeid column
expr_all2 <- expr_all |>
  as.data.frame() |>
  tibble::rownames_to_column("probeid")    # <- uses SAME NAME as annotation

# 5. Join directly (no rename needed)
expr_annotated <- dplyr::left_join(
  probe_to_gene,
  expr_all2,
  by = "probeid"
)

```

## 7. **Save Annotated Expression Matrix**

```{r}
# Save the fully annotated expression matrix before filtering.
# This file includes:
#   - probe IDs
#   - gene symbols
#   - gene names
#   - expression values for all 60 samples
#
# This serves as a complete reference version of the dataset.
# The filtered version (created in Step 8) will be used for downstream analysis (PCA, differential expression, clustering, heatmaps, etc.).

readr::write_tsv(expr_annotated, "../_raw/data/expression_annotated.tsv")
```
